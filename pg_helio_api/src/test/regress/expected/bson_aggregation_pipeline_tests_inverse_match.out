SET search_path TO helio_api,helio_core,helio_api_catalog;
SET helio_api.next_collection_id TO 3900;
SET helio_api.next_collection_index_id TO 3900;
-- Insert data
SELECT helio_api.insert_one('invmatch','airports','{ "_id": 1, "airport_id": 10165, "city": "Adak Island", "state": "AK", "name": "Adak", "rule": { "flight_type": "private"} }', NULL);
NOTICE:  creating collection
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','airports','{ "_id": 3, "airport_id": 11308, "city": "Dothan", "state": "AL", "name": "Dothan Regional", "rule": { "$or": [ { "origin": "WA"}, {"flight_type": "private"}] } }', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','airports','{ "_id": 4, "airport_id": 11778, "city": "Fort Smith", "state": "AR", "name": "Fort Smith Regional", "rule": { "$in": [{"is_emergency": true}, {"is_vip": true}] }}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','airports','{ "_id": 6, "airport_id": 14689, "city": "Santa Barbara", "state": "CA", "name": "Santa Barbara Municipal", "rule": { "$or": [ {"$and": [{"flight_type": "private"}, {"origin": "CA"}]}, {"$or": [{"is_emergency": true}, {"is_vip": true}]} ] }}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','airports','{ "_id": 7, "airport_id": 13442, "city": "Everet", "state": "WA", "name": "Paine Field", "rule": { "tags": { "$all": ["private", "vip"]}}}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

-- positive cases
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "AK"}}, { "$inverseMatch": {"path": "rule", "input": {"flight_type": "public"}}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "AK"}}, { "$inverseMatch": {"path": "rule", "input": {"flight_type": "private"}}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "AL"}}, { "$inverseMatch": {"path": "rule", "input": {"flight_type": "public"}}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "AL"}}, { "$inverseMatch": {"path": "rule", "input": {"flight_type": "private"}}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "AR"}}, { "$inverseMatch": {"path": "rule", "input": {"is_emergency": true}}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "CA"}}, { "$inverseMatch": {"path": "rule", "input": { "flight_type": "private", "origin": "CA" }}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "CA"}}, { "$inverseMatch": {"path": "rule", "input": { "flight_type": "public", "origin": "CA" }}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "CA"}}, { "$inverseMatch": {"path": "rule", "input": { "flight_type": "public", "origin": "CA", "is_vip": true }}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "AR"}}, { "$inverseMatch": {"path": "rule", "input": [{ "flight_type": "private"}, {"is_emergency": true}]}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{"$match": {"state": "WA"}}, { "$inverseMatch": {"path": "rule", "input": { "tags": ["private", "vip"]}}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{ "$inverseMatch": {"path": "rule", "input": { "origin": "WA" }}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
-- Validate errors
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [ { "$inverseMatch": {"pathRule": "rule", "input": {"flight_type": "private"} }}]}');
ERROR:  unrecognized argument to $inverseMatch: 'pathRule'
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [ { "$inverseMatch": {"path": "rule", "inputValue": {"flight_type": "private"} }}]}');
ERROR:  unrecognized argument to $inverseMatch: 'inputValue'
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [ { "$inverseMatch": {"path": "", "input": {"flight_type": "private"} }}]}');
ERROR:  Missing 'path' parameter to $inverseMatch
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [ { "$inverseMatch": {"path": "rule", "input": ["flight_type", "private"] }}]}');
ERROR:  $inverseMatch requires that if 'input' is an array its contents be documents, found: string
HINT:  $inverseMatch requires that if 'input' is an array its contents be documents, found: string
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [ { "$inverseMatch": {"path": "rule", "input": [{"flight_type": "private"}, ""] }}]}');
ERROR:  $inverseMatch requires that if 'input' is an array its contents be documents, found: string
HINT:  $inverseMatch requires that if 'input' is an array its contents be documents, found: string
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [ { "$inverseMatch": [{"path": "rule", "input": [{"flight_type": "private"}, ""] }, {"path": "rule2", "input": {}}]}]}');
ERROR:  $inverseMatch requires a document as an input instead got: array
HINT:  $inverseMatch requires a document as an input instead got: array
-- insert a document with an invalid query
SELECT helio_api.insert_one('invmatch','airports','{ "_id": 8, "airport_id": 13442, "city": "Everet", "state": "WA", "name": "Paine Field", "specialRule": { "tags": { "$allValues": ["private", "vip"]}}}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

-- any inverseMatch that queries that path should fail
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{ "$inverseMatch": {"path": "specialRule", "input": { "origin": "WA" }, "defaultResult": false}}]}');
ERROR:  unknown operator: $allValues
HINT:  unknown operator: $allValues
-- if we query "rule" path without defaultResult in the spec it should not match for the Everet airport which doesn't define the rule as the default value is false
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{ "$inverseMatch": {"path": "rule", "input": { "origin": "WA" }}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
-- with defaultResult true should return all documents that don't define the path and false shouldn't return them
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{ "$inverseMatch": {"path": "rule", "input": { "origin": "WA" }, "defaultResult": true}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
SELECT document FROM bson_aggregation_pipeline('invmatch', '{ "aggregate": "airports", "pipeline": [{ "$inverseMatch": {"path": "rule", "input": { "origin": "WA" }, "defaultResult": false}}]}');
ERROR:  function helio_api_catalog.bson_value_dollar_eq(internal, bson) does not exist
-- add tests with lookup for RBAC "like" scenarios
SELECT helio_api.insert_one('invmatch','user_roles','{ "_id": 1, "user_id": 100, "roles": ["basic"]}', NULL);
NOTICE:  creating collection
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','user_roles','{ "_id": 2, "user_id": 101, "roles": ["basic", "sales"]}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','user_roles','{ "_id": 3, "user_id": 102, "roles": ["admin"]}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','sales','{ "_id": 1, "order": 100, "paid": true, "total": 0, "rule": {"roles": {"$in": ["basic", "sales", "admin"]}}}', NULL);
NOTICE:  creating collection
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','sales','{ "_id": 2, "order": 102, "paid": true, "total": 1000, "rule": {"roles": {"$in": ["sales", "admin"]}}}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT helio_api.insert_one('invmatch','sales','{ "_id": 3, "order": 103, "paid": true, "total": 1000, "rule": {"roles": {"$in": ["admin"]}}}', NULL);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$lookup": { "from": "user_roles", "pipeline": [ { "$match": {"user_id": 100} } ], "as": "roles" }}, { "$inverseMatch": {"path": "rule", "input": "$roles"}}, {"$project": {"roles": 0, "rule": 0}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$lookup": { "from": "user_roles", "pipeline": [ { "$match": {"user_id": 101} } ], "as": "roles" }}, { "$inverseMatch": {"path": "rule", "input": "$roles"}}, {"$project": {"roles": 0, "rule": 0}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$lookup": { "from": "user_roles", "pipeline": [ { "$match": {"user_id": 102} } ], "as": "roles" }}, { "$inverseMatch": {"path": "rule", "input": "$roles"}}, {"$project": {"roles": 0, "rule": 0}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
-- use from collection instead of lookup (new feature)
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": 100}}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": 101}}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": 102}}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": 102}}, {"$project": {"roles": 1, "_id": 0}}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": { "$lt": 102 }}}, {"$limit": 1}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": { "$ne": 200 }}}, {"$limit": 1}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": { "$lte": 102 }}}, {"$limit": 2}]}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": []}} ], "cursor": {} }');
ERROR:  function helio_api_catalog.bson_value_dollar_in(internal, bson) does not exist
EXPLAIN (COSTS OFF, VERBOSE ON) SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": { "$ne": 200 }}}, {"$limit": 1}]}} ], "cursor": {} }'); 
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on helio_data.documents_3902 collection
   Output: collection.document
   Recheck Cond: (collection.shard_key_value = '3902'::bigint)
   Filter: helio_api_internal.bson_dollar_inverse_match(collection.document, $1)
   InitPlan 2 (returns $1)
     ->  Result
           Output: helio_api_internal.bson_dollar_merge_documents('{ "path" : "rule", "defaultResult" : false }'::bson, $0)
           InitPlan 1 (returns $0)
             ->  Limit
                   Output: (COALESCE(bson_array_agg(collection_0_1.document, 'input'::text), '{ "input" : [  ] }'::bson))
                   ->  Aggregate
                         Output: COALESCE(bson_array_agg(collection_0_1.document, 'input'::text), '{ "input" : [  ] }'::bson)
                         ->  Bitmap Heap Scan on helio_data.documents_3901 collection_0_1
                               Output: collection_0_1.shard_key_value, collection_0_1.object_id, collection_0_1.document, collection_0_1.creation_time
                               Recheck Cond: (collection_0_1.shard_key_value = '3901'::bigint)
                               Filter: (collection_0_1.document @!= '{ "user_id" : { "$numberInt" : "200" } }'::bson)
                               ->  Bitmap Index Scan on _id_
                                     Index Cond: (collection_0_1.shard_key_value = '3901'::bigint)
   ->  Bitmap Index Scan on _id_
         Index Cond: (collection.shard_key_value = '3902'::bigint)
(20 rows)

EXPLAIN (COSTS OFF, VERBOSE ON) SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "user_roles", "pipeline": [{"$match": {"user_id": { "$ne": 200 }}}]}} ], "cursor": {} }'); 
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on helio_data.documents_3902 collection
   Output: collection.document
   Recheck Cond: (collection.shard_key_value = '3902'::bigint)
   Filter: helio_api_internal.bson_dollar_inverse_match(collection.document, $1)
   InitPlan 2 (returns $1)
     ->  Result
           Output: helio_api_internal.bson_dollar_merge_documents('{ "path" : "rule", "defaultResult" : false }'::bson, $0)
           InitPlan 1 (returns $0)
             ->  Aggregate
                   Output: COALESCE(bson_array_agg(collection_0_1.document, 'input'::text), '{ "input" : [  ] }'::bson)
                   ->  Bitmap Heap Scan on helio_data.documents_3901 collection_0_1
                         Output: collection_0_1.shard_key_value, collection_0_1.object_id, collection_0_1.document, collection_0_1.creation_time
                         Recheck Cond: (collection_0_1.shard_key_value = '3901'::bigint)
                         Filter: (collection_0_1.document @!= '{ "user_id" : { "$numberInt" : "200" } }'::bson)
                         ->  Bitmap Index Scan on _id_
                               Index Cond: (collection_0_1.shard_key_value = '3901'::bigint)
   ->  Bitmap Index Scan on _id_
         Index Cond: (collection.shard_key_value = '3902'::bigint)
(18 rows)

EXPLAIN (COSTS OFF, VERBOSE ON) SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "input": {}}} ], "cursor": {} }'); 
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on helio_data.documents_3902 collection
   Output: collection.document
   Recheck Cond: (collection.shard_key_value = '3902'::bigint)
   Filter: helio_api_internal.bson_dollar_inverse_match(collection.document, '{ "path" : "rule", "input" : {  } }'::bson)
   ->  Bitmap Index Scan on _id_
         Index Cond: (collection.shard_key_value = '3902'::bigint)
(6 rows)

-- negative cases
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": {}, "input": "$roles"}} ], "cursor": {} }');
ERROR:  BSON field '$inverseMatch.path' is the wrong type 'object', expected type 'string'
HINT:  BSON field '$inverseMatch.path' is the wrong type 'object', expected type 'string'
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "", "input": "$roles"}} ], "cursor": {} }');
ERROR:  Missing 'path' parameter to $inverseMatch
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "input": [true]}} ], "cursor": {} }');
ERROR:  $inverseMatch requires that if 'input' is an array its contents be documents, found: bool
HINT:  $inverseMatch requires that if 'input' is an array its contents be documents, found: bool
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "input": true}} ], "cursor": {} }');
ERROR:  $inverseMatch requires that 'input' be a document or an array of documents, found: bool
HINT:  $inverseMatch requires that 'input' be a document or an array of documents, found: bool
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "input": {}, "from": "collection"}} ], "cursor": {} }');
ERROR:  'input' and 'from' can't be used together in an $inverseMatch stage.
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "collection"}} ], "cursor": {} }');
ERROR:  'pipeline' argument is required when 'from' is specified in an $inverseMatch stage.
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"rule": "rule"}} ], "cursor": {} }');
ERROR:  unrecognized argument to $inverseMatch: 'rule'
SELECT document from bson_aggregation_pipeline('invmatch', '{ "aggregate": "sales", "pipeline": [ { "$inverseMatch": {"path": "rule", "from": "mycoll", "pipeline": []}} ], "cursor": {} }');
ERROR:  'from' collection: 'invmatch.mycoll' doesn't exist.
